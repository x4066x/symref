# シンボル存在確認機能追加のPBI

## 概要
アナライザーに`hasSymbol`メソッドを実装し、シンボルの存在確認機能を共通化します。既存の`findDefinitionNode`メソッドをラップして、すべてのコマンドで一貫したシンボル検証とエラーメッセージを提供します。

## 目的
- シンボル存在確認を共通機能として実装し、各コマンドでの重複コードを削減する
- すべてのコマンドで一貫したエラーハンドリングを実現する
- 複雑なシンボル名や特殊文字を含むシンボル名の処理を改善する
- ユーザーに対して統一された明確なエラーメッセージを提供する

## 受け入れ基準
1. ✅ `SymbolFinder`クラスに`hasSymbol`メソッドが実装されている
2. ✅ すべてのコマンド（refs, dead, trace, callers）が新しい検証メソッドを使用している
3. ✅ エラーメッセージの形式と出力先（stderr）がすべてのコマンドで統一されている
4. ✅ 特殊文字を含むシンボル名（スペース、ドット、括弧など）が正しく処理される
5. ✅ 単体テストと統合テストが追加されている

## SBI（ステップバイステップ手順）

### ステップ1: `hasSymbol`メソッドの実装 ✅
- ✅ `SymbolFinder`クラスに`hasSymbol`メソッドを追加する
  - 実装内容: `src/analyzer/SymbolFinder.ts`に`hasSymbol(symbolName: string): boolean`メソッドを追加
  - メソッドは`findDefinitionNode`の結果が`undefined`でないかを確認する単純な実装
- ✅ 既存の`findDefinitionNode`メソッドをラップしたシンプルな実装にする
  - 実装内容: `const definitionNode = this.findDefinitionNode(symbolName); return definitionNode !== undefined;`
- ✅ メソッドの仕様：
  - ✅ 入力：シンボル名（文字列）
  - ✅ 出力：ブール値（シンボルが存在するかどうか）
- ✅ メソッドの単体テストを作成する
  - 実装内容: `test/SymbolFinder.test.ts`に単体テストを追加
  - テスト内容: クラス、関数、定数、インターフェースなど様々なタイプのシンボルの存在確認
  - テスト内容: 存在しないシンボルや大文字小文字の区別に関するテスト

### ステップ2: `analyzeSymbol`メソッドの修正 ✅
- ✅ `SymbolReferenceAnalyzer`の`analyzeSymbol`メソッドを修正し、`hasSymbol`を使ったより明確なエラーハンドリングを実装
- ✅ エラーメッセージの形式を統一
- ✅ `SymbolReferenceAnalyzer`にも`hasSymbol`メソッドを追加して内部の`symbolFinder.hasSymbol`を呼び出す実装

### ステップ3: コマンドの修正 - refs ✅
- ✅ `RefsCommand`を修正して新しい検証メソッドを使用するように変更
- ✅ カンマ区切りとスペース区切りの両方で一貫したエラー処理を実装
- ✅ エラーメッセージの形式を統一

### ステップ4: コマンドの修正 - trace ✅
- ✅ `TraceCommand`を修正して開始シンボルと終了シンボルの検証に`hasSymbol`を使用
- ✅ エラーメッセージの形式を統一
- ✅ 存在しないシンボルに対する明確なエラーメッセージを実装

### ステップ5: コマンドの修正 - callers ✅
- ✅ `CallersCommand`を修正して`hasSymbol`を使用するように変更
- ✅ 複数シンボル指定時のエラー処理を統一
- ✅ エラーメッセージの形式を統一

### ステップ6: コマンドの修正 - dead ✅
- ✅ `DeadCommand`のエラーメッセージの形式を他コマンドと統一
- ✅ ファイル存在確認のエラーメッセージを統一
- ✅ 同一形式のエラー出力を実装

### ステップ7: エラー出力の共通化 ✅
- ✅ すべてのコマンドで統一されたエラー表示方法を実装
- ✅ エラーメッセージを全て`process.stderr.write`に出力するように変更
- ✅ エラー発生時の終了コードを`1`に統一

### ステップ8: 統合テスト ✅
- ✅ 各コマンドが`hasSymbol`を正しく使用しているか確認する統合テストを作成
- ✅ 特殊なシンボル名のテストケースを追加（スペース、特殊文字、アンダースコアなど）
- ✅ エラーメッセージの一貫性を検証するテスト

## 技術的詳細
- `hasSymbol`の実装は既存の`findDefinitionNode`メソッドを利用し、結果が`undefined`でないかどうかをチェックする単純なものにする
- エラーメッセージは全コマンドで統一し、`stderr`に出力する
- エラー発生時の終了コードは、エラーが1つでもあれば`1`、それ以外は`0`に統一する
- シンボル検証はパフォーマンスに影響する可能性があるため、必要な場合のみ行う最適化を検討する

## 参照するコード
- `src/analyzer/SymbolFinder.ts`の`findDefinitionNode`メソッド
- `src/analyzer/SymbolReferenceAnalyzer.ts`の`analyzeSymbol`メソッド
- 各コマンドクラス（`RefsCommand`, `TraceCommand`, `CallersCommand`, `DeadCommand`）

## 工数見積もり
- 開発期間: 3人日
- 難易度: 中

## 実装ステータス
- ステップ1: ✅ 完了（2023-03-25）
  - `hasSymbol`メソッドを実装し、単体テストも追加済み
  - テスト実行結果: すべてのテストが成功
  - 動作確認: `refs`コマンドで存在するシンボルと存在しないシンボルの両方をテストし、期待通りに動作することを確認
- ステップ2: ✅ 完了
  - `SymbolReferenceAnalyzer`の`analyzeSymbol`メソッドを修正し、`hasSymbol`を使用するように実装
  - `SymbolReferenceAnalyzer`にパブリックな`hasSymbol`メソッドを追加し、内部の`symbolFinder.hasSymbol`を呼び出すようにした
  - エラーメッセージを統一形式に変更
- ステップ3: ✅ 完了
  - `RefsCommand`を修正し、新しい検証メソッドを使用するように変更
  - カンマ区切りとスペース区切りの両方で一貫したエラー処理を実装
  - エラーメッセージを`process.stderr.write`を使って統一形式で出力するように変更
- ステップ4: ✅ 完了
  - `TraceCommand`の`execute`メソッドを修正し、`hasSymbol`メソッドで存在確認を行うように実装
  - 開始シンボルと終了シンボルを個別に検証し、エラーの場合は早期リターン
  - エラーメッセージを統一された形式で出力
- ステップ5: ✅ 完了
  - `CallersCommand`を修正し、`hasSymbol`を使用して各シンボルの存在確認を実装
  - 複数シンボル指定時に一貫したエラー処理を実装
  - エラーメッセージを統一形式で出力するように変更
- ステップ6: ✅ 完了
  - `DeadCommand`のエラーメッセージ出力を他コマンドと同様に`process.stderr.write`を使って統一
  - ファイル存在確認のエラーメッセージを統一形式に変更
- ステップ7: ✅ 完了
  - すべてのコマンドで統一されたエラー表示方法を実装
  - エラーメッセージを`process.stderr.write`を使って出力するように変更
  - エラー発生時の終了コードを`1`に統一
- ステップ8: ✅ 完了
  - 統合テスト`symbol-validation.test.ts`を追加し、各コマンドが`hasSymbol`を正しく使用しているか検証
  - 特殊なシンボル名（`$`記号、アンダースコア、数字を含む名前など）のテストケースを追加
  - エラーメッセージの一貫性を検証するテストを実装

## 動作確認結果
- `refs`コマンド
  - 存在するシンボルに対して正常に参照一覧を表示
  - 存在しないシンボルに対して統一されたエラーメッセージを表示
- `trace`コマンド
  - 存在するシンボル間の経路分析を正常に実行
  - 存在しないシンボルに対して統一されたエラーメッセージを表示
- `callers`コマンド
  - 存在するシンボルの呼び出し元を正常に分析
  - 存在しないシンボルに対して統一されたエラーメッセージを表示
- `dead`コマンド
  - 存在するファイルの未使用シンボルを正常に検出
  - 存在しないファイルに対して統一されたエラーメッセージを表示
  - 複数ファイルを指定した場合も正常に処理

## 結論
すべての受け入れ基準を満たす実装が完了し、テストと動作確認によってその機能が検証されました。シンボル存在確認機能が共通化され、すべてのコマンドで一貫したエラーハンドリングとメッセージング形式が採用されました。 